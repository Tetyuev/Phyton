# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()),
# который должен принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц: 3 на 2, 3 на 3, 2 на 4.
#
# 31    32         3    5    32        3    5    8    3
# 37    43         2    4    6         8    3    7    1
# 51    86        -1   64   -8
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции
# сложения двух объектов класса Matrix (двух матриц). Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки
# первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.
#
# import copy
# class Matrix():
#     def __init__(self, matr):
#         self.matr=matr
#     def __str__(self):
#         return f'{self.matr}'
#     def __add__(self, other):
#         res = copy.deepcopy(self.matr)
#         for i in range(len(res)):
#             for a in range(len(res[i])):
#                 res[i][a] = self.matr[i][a]+other.matr[i][a]
#         return Matrix(res)
#
#
# m=Matrix([[5,5,5],[4,4,4]])
# n=Matrix([[3,2,1],[3,2,1]])
# New_matrix=m+n
# print(New_matrix)


# 2. Реализовать проект расчёта суммарного расхода ткани на производство одежды.
# Основная сущность (класс) этого проекта — одежда, которая может иметь определённое название.
# К типам одежды в этом проекте относятся пальто и костюм.
# У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма).
# Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5),
# для костюма (2*H + 0.3). Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани.
# Проверить на практике полученные на этом уроке знания:
# реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.

# from abc import ABC, abstractmethod
# class Clothes(ABC):
#     def __init__(self, param):
#         self.param = param
#     @abstractmethod
#     def fabric(self):
#         pass
# class Coat(Clothes):
#     @property
#     def fabric(self):
#         return self.param/6.5 + 0.5
# class Suit(Clothes):
#     @property
#     def fabric(self):
#         return self.param*2+0.3
# a = Coat(50)
# b = Suit(172)
# print(f'Расход ткани на пальто {a.fabric:.2f} метров')
# print(f'Расход ткани на костюм {b.fabric:.2f} метров')
# print(f'Общий расход ткани {(a.fabric+b.fabric):.2f} метров')


# 3. Реализовать программу работы с органическими клетками, состоящими из ячеек.
# Необходимо создать класс Клетка. В его конструкторе инициализировать параметр,
# соответствующий количеству ячеек клетки (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и
# целочисленное (с округлением до целого) деление клеток, соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек
# двух клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создаётся общая клетка из двух.
# Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
# Деление. Создаётся общая клетка из двух.
# Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
## В классе необходимо реализовать метод make_order(),
# принимающий экземпляр класса и количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5.
# Тогда метод make_order() вернёт строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5.
# Тогда метод make_order() вернёт строку: *****\n*****\n*****.

class Cell():
    def __init__(self, well):
        self.well=well
    def __str__(self):
        return f'{self.well}'
    def __add__(self, other):
        return Cell(self.well+other.well)
    def __sub__(self, other):
        if self.well >= other.well:
            return Cell(self.well - other.well)
        else:
            print ('Нельзя вычесть большее из меньшего')
    def __mul__(self, other):
        return Cell(self.well*other.well)
    def __truediv__(self, other):
        return Cell(self.well//other.well)
    def make_order(self, num_well_in_row):
        x = self.well
        while x>0:
            for i in range(num_well_in_row):
                print("*", end='')
                x-=1
                if x<=0:
                    break
            print('\n')


a=Cell(22)
b=Cell(15)
# print(a+b)
# print(a - b)
# print(a*b)
# print(a/b)
print(a.make_order(10))

